type Username = text;
type UserRecord = 
 record {
   avatar: AvatarID;
   description: Description;
   friends: vec UserID;
   registrationDate: RegistrationDate;
   userId: UserID;
   username: Username;
 };
type UserId = principal;
type UserID = principal;
type UserDetails = 
 record {
   friends: vec FriendDetails;
   user: UserRecord;
 };
type Tournament = 
 record {
   bracketCreated: bool;
   expirationDate: Time;
   id: nat;
   isActive: bool;
   matchCounter: nat;
   name: text;
   participants: vec principal;
   prizePool: text;
   registeredParticipants: vec principal;
   startDate: Time;
 };
type TokenID = nat;
type Time = int;
type StastisticsGameID = nat;
type SearchStatus = 
 variant {
   Assigned;
   Available;
   NotAvailable;
 };
type RewardsUser = 
 record {
   expiration: nat64;
   finish_date: nat64;
   finished: bool;
   id_reward: nat;
   prize_amount: nat;
   prize_type: PrizeType;
   progress: float64;
   rewardType: RewardType;
   start_date: nat64;
   total: float64;
 };
type RewardType = 
 variant {
   GamesCompleted;
   GamesWon;
   LevelReached;
 };
type RewardProgress = 
 record {
   progress: float64;
   rewardType: RewardType;
 };
type Reward = 
 record {
   end_date: nat64;
   id: nat;
   name: text;
   prize_amount: nat;
   prize_type: PrizeType;
   rewardType: RewardType;
   start_date: nat64;
   total: float64;
 };
type RegistrationDate = int;
type PrizeType = 
 variant {
   Chest;
   Flux;
   Shards;
 };
type PlayerPreferences = 
 record {
   language: nat;
   playerChar: text;
 };
type PlayerName = text;
type PlayerInfo = 
 record {
   elo: float64;
   id: UserId;
   lastPlayerActive: nat64;
   matchAccepted: bool;
   playerGameData: text;
 };
type PlayerId = principal;
type PlayerID = principal;
type PlayerGamesStats = 
 record {
   energyGenerated: float64;
   energyUsed: float64;
   energyWasted: float64;
   gamesLost: nat;
   gamesPlayed: nat;
   gamesWon: nat;
   totalDamageCrit: float64;
   totalDamageDealt: float64;
   totalDamageEvaded: float64;
   totalDamageTaken: float64;
   totalGamesGameMode: vec GamesWithGameMode;
   totalGamesWithCharacter: vec GamesWithCharacter;
   totalGamesWithFaction: vec GamesWithFaction;
   totalXpEarned: float64;
 };
type Player = 
 record {
   elo: float64;
   id: PlayerId;
   level: Level;
   name: PlayerName;
 };
type OverallStats = 
 record {
   totalDamageDealt: float64;
   totalEnergyGenerated: float64;
   totalEnergyUsed: float64;
   totalEnergyWasted: float64;
   totalGamesGameMode: vec GamesWithGameMode;
   totalGamesMP: nat;
   totalGamesPlayed: nat;
   totalGamesSP: nat;
   totalGamesWithCharacter: vec GamesWithCharacter;
   totalGamesWithFaction: vec GamesWithFaction;
   totalKills: float64;
   totalTimePlayed: float64;
   totalXpEarned: float64;
 };
type MatchmakingStatus = 
 variant {
   Accepted;
   Accepting;
   Ended;
   InGame;
   Reserved;
   Searching;
 };
type MatchData = 
 record {
   gameId: nat;
   player1: PlayerInfo;
   player2: opt PlayerInfo;
   status: MatchmakingStatus;
 };
type Match = 
 record {
   id: nat;
   nextMatchId: opt nat;
   participants: vec principal;
   result: opt record {
                 score: text;
                 winner: principal;
               };
   status: text;
   tournamentId: nat;
 };
type Level = nat;
type GamesWithGameMode = 
 record {
   gameModeID: nat;
   gamesPlayed: nat;
   gamesWon: nat;
 };
type GamesWithFaction = 
 record {
   factionID: nat;
   gamesPlayed: nat;
   gamesWon: nat;
 };
type GamesWithCharacter = 
 record {
   characterID: text;
   gamesPlayed: nat;
   gamesWon: nat;
 };
type FullPlayerInfo = 
 record {
   elo: float64;
   id: UserId;
   matchAccepted: bool;
   playerGameData: text;
   playerName: text;
 };
type FullMatchData = 
 record {
   gameId: nat;
   player1: FullPlayerInfo;
   player2: opt FullPlayerInfo;
   status: MatchmakingStatus;
 };
type FriendDetails = 
 record {
   avatar: AvatarID;
   userId: UserID;
   username: Username;
 };
type Description = text;
type Cosmicrafts = 
 service {
   addFriend: (UserID) -> (bool, text);
   addProgressToRewards: (principal, vec RewardProgress) -> (bool, text);
   addReward: (Reward) -> (bool, text, nat);
   adminUpdateMatch: (nat, nat, nat, text) -> (bool);
   cancelMatchmaking: () -> (bool, text);
   claimReward: (nat) -> (bool, text);
   claimedReward: (principal, nat) -> (bool, text);
   createPlayer: (text) -> (bool, text);
   createReward: (text, RewardType, PrizeType, nat, float64, nat64) -> (
    bool, text);
   createTournament: (text, Time, text, Time) -> (nat);
   deleteAllTournaments: () -> (bool);
   disputeMatch: (nat, nat, text) -> (bool);
   generateUUID64: () -> (nat);
   getActiveTournaments: () -> (vec Tournament) query;
   getAllActiveRewards: () -> (nat, vec Reward) query;
   getAllOnValidation: () ->
    (vec record {
           StastisticsGameID;
           BasicStats;
         }) query;
   getAllPlayers: () -> (vec Player) query;
   getAllSearching: () -> (vec MatchData) query;
   getAllTournaments: () -> (vec Tournament) query;
   getAllUsersRewards: () -> (vec record {
                                    principal;
                                    vec RewardsUser;
                                  }) query;
   getAverageStats: () -> (AverageStats) query;
   getBasicStats: (StastisticsGameID) -> (opt BasicStats) query;
   getFriendsList: () -> (opt vec UserID) query;
   getICPBalance: () -> (record {e8s: nat64;});
   getInactiveTournaments: () -> (vec Tournament) query;
   getMatchData: (nat) -> (opt MatchData) query;
   /// func getGamesByELOsorted(targetELO : Float, maxELO : Float) : [MatchData] {
   ///     var _gamesByELO : [MatchData] = [];
   ///     var _now : Nat64 = Nat64.fromIntWrap(Time.now());
   ///     for (m in searching.vals()) {
   ///       /// Validate game is active
   ///       if ((m.player1.lastPlayerActive + inactiveSeconds) >= _now) {
   ///         /// Validate game is within the ELO range
   ///         if (m.player1.elo >= (targetELO - maxELO) and m.player1.elo <= (targetELO + maxELO)) {
   ///           /// To-Do: Add other loop to sort asc by ELO where all registries are passed and the new one is added in the right place
   ///           if (Array.size(_gamesByELO) == 0) {
   ///             _gamesByELO := [m];
   ///           } else {
   ///             var _orderedGamesByELO : [MatchData] = [];
   ///             var _added : Bool = false;
   ///             for (n in _gamesByELO.vals()) {
   ///               if (n.player1.elo > m.player1.elo) {
   ///                 /// Add the new match in the right place
   ///                 _orderedGamesByELO := Array.append(_gamesByELO, [m]);
   ///                 _added := true;
   ///                 /// Also add the current registry
   ///                 _orderedGamesByELO := Array.append(_gamesByELO, [n]);
   ///               } else {
   ///                 /// Only add the current registry
   ///                 _orderedGamesByELO := Array.append(_gamesByELO, [n]);
   ///               };
   ///             };
   ///             if (_added == false) {
   ///               _orderedGamesByELO := Array.append(_gamesByELO, [m]);
   ///             };
   ///             _gamesByELO := _orderedGamesByELO;
   ///           };
   ///         };
   ///       };
   ///     };
   ///     _gamesByELO;
   ///   };
   /// *
   getMatchSearching: (text) -> (SearchStatus, nat, text);
   getMyAverageStats: () -> (opt AverageStats) query;
   getMyMatchData: () -> (opt FullMatchData, nat) composite_query;
   getMyPlayerData: () -> (opt Player) query;
   getMyStats: () -> (opt PlayerGamesStats) query;
   getOverallStats: () -> (OverallStats) query;
   /// PLAYERS LOGIC
   getPlayer: () -> (opt Player);
   getPlayerAverageStats: (principal) -> (opt AverageStats) query;
   getPlayerData: (principal) -> (opt Player) composite_query;
   getPlayerElo: (principal) -> (float64) query;
   getPlayerPreferences: () -> (opt PlayerPreferences);
   getPlayerStats: (principal) -> (opt PlayerGamesStats) query;
   getRegisteredUsers: (nat) -> (vec principal) query;
   getReward: (nat) -> (opt Reward) query;
   getTournamentBracket: (nat) -> (record {matches: vec Match;}) query;
   getUserDetails: (UserID) -> (opt UserDetails) query;
   getUserReward: (PlayerID, nat) -> (opt RewardsUser) query;
   isGameMatched: () -> (bool, text) query;
   joinTournament: (nat) -> (bool);
   mergeSkinNFTs: (nat, nat) -> (bool, text);
   /// Mint Chests
   mintChest: (principal, nat) -> (bool, text);
   /// Mint deck with 8 units and random rarity within a range provided
   mintDeck: (principal) -> (bool, text);
   mintNFT: (principal, nat, nat) -> (bool, text);
   mintTokens: (principal, nat, nat) -> (bool, text);
   openChests: (nat) -> (bool, text);
   registerUser: (Username, AvatarID) -> (bool, UserID);
   saveFinishedGame: (StastisticsGameID, BasicStats) -> (bool, text);
   savePlayerChar: (text) -> (bool, text);
   savePlayerLanguage: (nat) -> (bool, text);
   savePlayerName: (text) -> (bool);
   searchUserByPrincipal: (UserID) -> (opt UserRecord) query;
   searchUserByUsername: (Username) -> (vec UserRecord) query;
   setGameOver: (principal) -> (bool, bool, opt principal);
   setGameValid: (StastisticsGameID) -> (bool);
   setPlayerActive: () -> (bool);
   submitFeedback: (nat, text) -> (bool);
   submitMatchResult: (nat, nat, text) -> (bool);
   updateAvatar: (AvatarID) -> (bool, UserID);
   updateBracket: (nat) -> (bool);
   updateBracketAfterMatchUpdate: (nat, nat, principal) -> ();
   updateDescription: (Description) -> (bool, UserID);
   updatePlayerElo: (principal, float64) -> (bool);
   updateUsername: (Username) -> (bool, UserID);
   upgradeNFT: (TokenID) -> (bool, text);
   /// func validateEnergyBalance(timeInSeconds : Float, energySpent : Float) : Bool {
   ///     let energyGenerated : Float = 30.0 + (0.5 * timeInSeconds);
   ///     return energyGenerated == energySpent;
   ///   };
   ///   func validateEfficiency(score : Float, energySpent : Float, efficiencyThreshold : Float) : Bool {
   ///     let efficiency : Float = score / energySpent;
   ///     return efficiency <= efficiencyThreshold;
   ///   };
   /// *
   validateGame: (float64, float64, float64, float64) -> (bool, text) query;
 };
type BasicStats = 
 record {
   botDifficulty: nat;
   botMode: nat;
   characterID: text;
   damageCritic: float64;
   damageDealt: float64;
   damageEvaded: float64;
   damageTaken: float64;
   deploys: float64;
   energyChargeRate: float64;
   energyGenerated: float64;
   energyUsed: float64;
   energyWasted: float64;
   faction: nat;
   gameMode: nat;
   kills: float64;
   secRemaining: float64;
   wonGame: bool;
   xpEarned: float64;
 };
type AverageStats = 
 record {
   averageDamageDealt: float64;
   averageEnergyGenerated: float64;
   averageEnergyUsed: float64;
   averageEnergyWasted: float64;
   averageKills: float64;
   averageXpEarned: float64;
 };
type AvatarID = nat;
service : () -> Cosmicrafts
